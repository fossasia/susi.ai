import _ from 'lodash';
// import { getWebSearchResults } from '../apis/index';

const userMessageGenerator = (text, timestamp, voice) => {
  return Promise.resolve({
    id: 'm_' + timestamp,
    authorName: 'You',
    date: new Date(timestamp),
    text: text,
    type: 'message',
    voice: voice,
  });
};

const susiMessageGenerator = (timestamp, voice, response) => {
  const { answers } = response;
  const defaultAnswer = {
    data: [
      {
        '0': '',
        timezoneOffset: new Date().getTimezoneOffset(),
        language: 'en',
      },
    ],
    metadata: {
      count: 1,
    },
    actions: [
      {
        type: 'answer',
        expression: "Hmm... I'm not sure if i understand you correctly.",
      },
    ],
    skills: ['/en_0090_fail.json'],
    persona: {},
  };

  if (_.isEmpty(answers)) {
    response.answers.push(defaultAnswer);
  }

  // Array of messages generated by traversing all the actions
  let generatedMessages = [];

  const answerResponse =
    answers[0].actions.length > 0 ? answers[0] : defaultAnswer;
  const actions = answerResponse.actions;
  actions.forEach((actionObj, index) => {
    let receivedMessage = {
      id: `m_${timestamp}_${index}`,
      authorName: 'SUSI',
      answer: answerResponse,
      text: '',
      response: {},
      actionType: actionObj.type,
      action: actionObj,
      allActions: actions.map(eachAction => eachAction.type),
      websearchresults: [],
      rssResults: [],
      type: 'message',
      voice: voice,
      lang: 'en-US',
    };

    try {
      receivedMessage.text = actionObj.expression;
    } catch (err) {
      if (err instanceof TypeError) {
        receivedMessage.text =
          'Sorry, I could not understand what you just said.';
      }
    }

    receivedMessage.lang = actionObj.language || 'en';

    const planDelay = actionObj.planDelay || 0;
    receivedMessage.date = new Date(timestamp + planDelay);
    receivedMessage.planDelay = planDelay;

    // // Websearch
    // if (actionObj.type === 'websearch') {
    //   const query = actionObj.query;
    //   let count = -1;
    //   if (actionObj.hasOwnProperty('count')) {
    //     count = actionObj.count;
    //   }
    //   let isResultFound = false;
    //   getWebSearchResults(query)
    //     .then(data => {
    //       if (count === -1) {
    //         count = data.relatedTopics.length + 1;
    //       }
    //       if (count > 0 && data.abstractText) {
    //         let abstractTile = {
    //           title: '',
    //           description: '',
    //           link: '',
    //           icon: '',
    //         };
    //         abstractTile.title = data.heading;
    //         abstractTile.description = data.abstractText;
    //         abstractTile.link = data.abstractURL;
    //         abstractTile.image = data.image;
    //         receivedMessage.websearchresults.push(abstractTile);
    //         count--;
    //       }
    //       for (
    //         let tileKey = 0;
    //         tileKey < data.relatedTopics.length && count > 0;
    //         tileKey++
    //       ) {
    //         const tileData = data.relatedTopics[tileKey];
    //         if (!tileData.hasOwnProperty('Name')) {
    //           let websearchTile = {
    //             title: '',
    //             description: '',
    //             link: '',
    //             icon: '',
    //           };
    //           if (tileData.result) {
    //             websearchTile.title = tileData.result.match(
    //               /<a [^>]+>([^<]+)<\/a>/,
    //             )[1];
    //             websearchTile.description = tileData.text;
    //             websearchTile.link = tileData.firstUrl;
    //             websearchTile.image = tileData.icon.url;
    //             receivedMessage.websearchresults.push(websearchTile);
    //             count--;
    //           } else {
    //             break;
    //           }
    //         }
    //       }
    //       generatedMessages.push(receivedMessage);
    //     })
    //     .catch(error => {
    //       console.log(error);
    //     });
    // }
    // // Rss
    // else if (actionObj.type === 'rss') {
    //   let count = -1;
    //   if (actionObj.hasOwnProperty('count')) {
    //     count = actionObj.count;
    //   }
    //   let data = response.answers[0].data;
    //   if (count === -1 || count > data.length) {
    //     count = data.length;
    //   }
    //   let pushedDataIndices = [];
    //   let remainingDataIndices = [];
    //   data.forEach((rssData, index) => {
    //     if (
    //       rssData.hasOwnProperty('image') &&
    //       pushedDataIndices.length < count
    //     ) {
    //       receivedMessage.rssResults.push(rssData);
    //       pushedDataIndices.push(index);
    //     } else {
    //       remainingDataIndices.push(index);
    //     }
    //   });
    //   count -= pushedDataIndices.length;
    //   generatedMessages.push(receivedMessage);
    //   return;
    // }
    generatedMessages.push(receivedMessage);
  });
  return Promise.resolve(generatedMessages);
};

export const formatUserMessage = payload => {
  const timestamp = Date.now();
  const { text, voice } = payload;
  payload.message = userMessageGenerator(text, timestamp, voice);
  return new Promise((resolve, reject) => {
    userMessageGenerator(text, timestamp, voice).then(message => {
      payload.message = message;
      resolve(payload);
    });
  });
};

export const formatSusiMessage = payload => {
  const { voice } = payload;
  let { response } = payload;

  const timestamp = Date.now();

  return new Promise((resolve, reject) => {
    susiMessageGenerator(timestamp, voice, response).then(generatedMessages => {
      resolve(generatedMessages);
    });
  });
};

export const createMessagePairArray = response => {
  let promisePairArray = [];
  response.cognitions.forEach(cognition => {
    const userMessage = userMessageGenerator(
      cognition.query,
      Date.parse(cognition.queryDate),
      false,
    );

    const susiMessage = susiMessageGenerator(
      Date.parse(cognition.answerDate),
      false,
      cognition,
    );

    const promisePair = new Promise((resolve, reject) => {
      Promise.all([userMessage, susiMessage]).then(resolvedPair => {
        resolve({
          userMessage: resolvedPair[0],
          susiMessage: resolvedPair[1],
        });
      });
    });

    promisePairArray = [...promisePairArray, promisePair];
  });

  return new Promise((resolve, reject) => {
    Promise.all(promisePairArray).then(resolvedPairArray => {
      resolve({ messagePairArray: resolvedPairArray });
    });
  });
};
